{
    "collab_server" : "",
    "contents" : "# Eight possible models:\n#    Model1 = constant unit\n#    Model2 = multiple unit\n#    Model3 = rating scale (GUM)\n#    Model4 = partial credit\n#    Model5 = generalized constant unit\n#    Model6 = generalized multiple unit\n#    Model7 = generalized rating scale\n#    Model8 = generalized graded unfolding (GGUM)\n\n# Generate.GGUM ----\nGenerate.Data.Unfold <- function(N, I, C, model = 8, seed = 123)\n{\n  set.seed(seed)\n  if (model > 4) {alpha  <- round(runif(I, .5, 2), 4)} else {alpha <- rep(1, I)}\n  delta             <- sort(round(rnorm(I, 0, 1), 4))\n  delta[delta < -2] <- -2\n  delta[delta > 2]  <- 2\n  if (length(C) == 1) {C <- rep(C, I)}\n  C.max             <- max(C)\n\n  # Taus (models 4 / 8)\n  if ((model == 4) || (model == 8))\n  {\n    tau.half          <- matrix(NA, nrow = I, ncol = C.max)\n    tau.half[, 1]     <- round(runif(I, .4, 1), 4)\n    for (i in 2:C.max) {\n      tau.half[, i]   <- (i <= C) * (tau.half[, i - 1] + .25 + round(rnorm(I, 0, .04), 4))\n    }\n    taus              <- cbind(-tau.half[, C.max:1], 0, tau.half)\n  }\n  # Taus (models 3 / 7)\n  if ((model == 3) || (model == 7))\n  {\n    tau.half        <- rep(NA, C.max)\n    tau.half[1]     <- round(runif(1, .4, 1), 4)\n    for (i in 2:C.max) {\n      tau.half[i]   <- tau.half[i - 1] + .25 + round(rnorm(1, 0, .04), 4)\n    }\n    taus            <- c(0, tau.half)\n    taus            <- matrix(rep(taus, I), nrow = I, byrow = TRUE)\n    for (i in 1:I) {\n      if (C[i] < C.max) taus[i, (C[i] + 2):(C.max + 1)] <- 0\n    }\n    taus            <- cbind(-taus[, (C.max + 1):2], taus)\n  }\n\n  theta             <- round(rnorm(N, 0, 1), 4)\n  M                 <- 2 * C + 1\n  probs.array       <- array(NA, dim = c(N, I, C.max + 1))\n  for (z in 0:C.max)\n  {\n    probs.array[, , z + 1] <- P.Model.3478(z, alpha, delta, taus, theta, C)\n  }\n  res               <- apply(probs.array, 1:2, function(vec) {which( rmultinom(1, 1, vec) == 1) - 1 })\n  res               <- cbind(res, 1:N, NA)\n\n  # Add last column with absolute frequencies:\n  res.tmp  <- res[, 1:(I + 1)]\n  res.ext  <- matrix(NA, ncol = I + 1, nrow = 0)\n  ctrl     <- 0\n  while (ctrl == 0)\n  {\n    n.cand   <- nrow(res.tmp) - 1\n    diff     <- res.tmp[-1, 1:I] - matrix(rep(res.tmp[1, 1:I], n.cand), nrow = n.cand, byrow = TRUE)\n    rs       <- which(rowSums(abs(diff)) == 0)\n    res.ext  <- rbind(res.ext, c(res.tmp[1, 1:I], length(rs) + 1))\n    res[res.tmp[c(1, rs + 1), I + 1, drop = FALSE], I + 2] <- nrow(res.ext)\n    res.tmp  <- res.tmp[-c(1, rs + 1), , drop = FALSE]\n    if (nrow(res.tmp) == 1)\n    {\n      ctrl    <- 1\n      res.ext <- rbind(res.ext, c(res.tmp[1, 1:I], 1))\n      res[res.tmp[1, I + 1, drop = FALSE], I + 2] <- nrow(res.ext)\n    }\n    if (nrow(res.tmp) == 0) {ctrl <- 1}\n  }\n  res <- res[, 1:I]\n  return(list(data.condensed = res.ext, alpha.gen = alpha, delta.gen = delta, taus.gen = taus, theta.gen = theta, data.full = res))\n}\n\n# GGUM.data.condense ----\n# GGUM.data.condense <- function(data)\n# {\n#   N    <- nrow(data)\n#   I    <- ncol(data)\n#   res  <- cbind(data, 1:N, NA)\n#\n#   # Add last column with absolute frequencies:\n#   res.tmp  <- res[, 1:(I + 1)]\n#   res.ext  <- matrix(NA, ncol = I + 1, nrow = 0)\n#   ctrl     <- 0\n#   while (ctrl == 0)\n#   {\n#     n.cand   <- nrow(res.tmp) - 1\n#     diff.NAs <- is.na(res.tmp[-1, 1:I]) * is.na(matrix(rep(res.tmp[1, 1:I], n.cand), nrow = n.cand, byrow = TRUE))\n#\n#     diff     <- res.tmp[-1, 1:I] == matrix(rep(res.tmp[1, 1:I], n.cand), nrow = n.cand, byrow = TRUE)\n#     rs       <- which(rowSums(abs(diff), na.rm = TRUE) + rowSums(diff.NAs) == I)\n#     res.ext  <- rbind(res.ext, c(res.tmp[1, 1:I], length(rs) + 1))\n#     res[res.tmp[c(1, rs + 1), I + 1, drop = FALSE], I + 2] <- nrow(res.ext)\n#     res.tmp  <- res.tmp[-c(1, rs + 1), , drop = FALSE]\n#     if (nrow(res.tmp) == 1)\n#     {\n#       ctrl    <- 1\n#       res.ext <- rbind(res.ext, c(res.tmp[1, 1:I], 1))\n#       res[res.tmp[1, I + 1, drop = FALSE], I + 2] <- nrow(res.ext)\n#     }\n#     if (nrow(res.tmp) == 0) {ctrl <- 1}\n#   }\n#   return(list(data.condensed = res.ext, ind = res[, I + 2]))\n# }\nGGUM.data.condense <- function(data)\n{\n  I       <- ncol(data)\n  idFac   <- as.integer(factor(apply(data, 1, paste, collapse = \"\")))\n  mat.ord <- cbind(data, idFac)[order(idFac), ]\n  mat.sub <- mat.ord[c(1, which(diff(sort(idFac)) == 1) + 1), 1:I]\n  return(list(data.condensed = cbind(mat.sub, table(idFac)), ind = idFac))\n}\n\n# GUM.initprm ----\nGUM.initprm <- function(data.condensed, C, threshold = 2)\n{\n  N              <- sum(data.condensed[, ncol(data.condensed)])\n  n.row          <- nrow(data.condensed)\n  I              <- ncol(data.condensed) - 1\n  data.full      <- matrix(unlist(sapply(1:n.row, function(x)\n  {\n    rep(data.condensed[x, 1:I], data.condensed[x, I + 1])\n  }\n  )), ncol = I, byrow = TRUE)\n  data.dich      <- matrix(NA, nrow = N, ncol = I)\n  threshold.int  <- rep(threshold, I)\n  threshold.int[which(C <= 2)] <- 1\n  threshold.mat  <- matrix(rep(threshold.int, N), nrow = N, byrow = TRUE)\n  data.dich[data.full >= threshold.mat] <- 1\n  data.dich[data.full <  threshold.mat] <- 0\n  delta.ini      <- rep(NA, I)\n  s.vec          <- colSums(data.dich, na.rm = TRUE)\n  sh             <- max(s.vec)\n  h              <- which(s.vec == sh)[1]\n  delta.ini[h]   <- 0\n  tau.B          <- -log(sh / (N - sh))\n  if (tau.B > 0) {tau.B <- -tau.B}\n  if ((tau.B < -3))\n  {\n    rescale.f <- (N * exp(2) / (1 + exp(2))) / sh\n    s.vec     <- rescale.f * s.vec\n    sh        <- max(s.vec)\n    tau.B     <- -log(sh / (N - sh))\n  }\n  for (i in (1:I)[-h])\n  {\n    func         <- function(dlt)\n    {\n      (exp(-dlt - tau.B) + exp(-2 * dlt - tau.B)) / (1 + exp(-dlt - tau.B) + exp(-2 * dlt - tau.B) + exp(-3 * dlt)) - s.vec[i] / N\n    }\n    my.root      <- try(uniroot(f = func, interval = c(0, 6), tol = 1e-20)$root, silent = TRUE)\n    delta.ini[i] <- if(\"try-error\" %in% class(my.root)) 2 else my.root\n  }\n  # Delta signs:\n  delta.sgn <- sign(principal(data.full, nfactors = 1, rotate = \"none\", scores = FALSE)$loadings[, 1])\n  delta.ini <- delta.ini * delta.sgn\n  # Taus:\n  taus.ini <- matrix(0, nrow = I, ncol = 2 * max(C) + 1)\n  for (i in 1:I)\n  {\n    taus.ini[i, (max(C) - C[i] + 1): max(C)] <- (C[i] + 1 - 1:C[i]) * tau.B / (C[i] - threshold.int[i] + 1)\n  }\n  taus.ini[, (max(C) + 2):(2 * max(C) + 1)] <- -taus.ini[, max(C):1]\n  #\n  return(list(delta.ini = delta.ini, taus.ini = taus.ini))\n}\n\n# P(Xs|theta) ----\n# Ls   <- function(data.condensed, alpha, delta, taus, nodes, C)\n# {\n#   I           <- length(alpha)\n#   C.max       <- max(C)\n#   data.s      <- data.condensed[, -(I + 1), drop = FALSE]\n#   S           <- nrow(data.condensed)\n#   N.nodes     <- length(nodes)\n#   probs.array <- array(NA, dim = c(N.nodes, I, C.max + 1))                                # N.nodes x I x (C + 1)\n#   for (z in 0:C.max)\n#   {\n#     probs.array[, , z + 1] <- P.Model.3478(z, alpha, delta, taus, nodes, C)\n#   }\n#   res <- matrix(NA, nrow = S, ncol = N.nodes)\n#   for (s in 1:S)\n#   {\n#     ind     <- matrix(0, nrow = I, ncol = C.max + 1)\n#     ind[matrix(c(1:I, data.s[s, ] + 1), ncol = 2, byrow = FALSE)] <- 1\n#     ind     <- aperm(array(rep(ind, N.nodes), dim = c(I, C.max + 1, N.nodes)), c(3, 1, 2)) # N.nodes x I x (C + 1)\n#     product <- probs.array * ind\n#     ind     <- matrix(1, nrow = I, ncol = C.max + 1)\n#     ind[matrix(c(1:I, data.s[s, ] + 1), ncol = 2, byrow = FALSE)] <- 0\n#     ind     <- aperm(array(rep(ind, N.nodes), dim = c(I, C.max + 1, N.nodes)), c(3, 1, 2))\n#     product <- product + ind\n#     res[s, ] <- apply(product, 1, prod, na.rm = TRUE)\n#   }\n#   return(res)\n# }\n############\nLs   <- function(data.condensed, alpha, delta, taus, nodes, C)\n{\n  I           <- length(alpha)\n  C.max       <- max(C)\n  data.s      <- data.condensed[, -(I + 1), drop = FALSE]\n  S           <- nrow(data.condensed)\n  N.nodes     <- length(nodes)\n  probs.array <- array(NA, dim = c(N.nodes, I, C.max + 1))                 # N.nodes x I x (C + 1)\n  for (z in 0:C.max)\n  {\n    probs.array[, , z + 1] <- P.Model.3478(z, alpha, delta, taus, nodes, C)\n  }\n  #\n  mat.ind <- t(data.s) + 1\n  ind.arr <- array(0, dim = c(I, S, C.max + 1))\n  for (i in 1:I) ind.arr[i, , ][cbind(1:S, mat.ind[i, ])] <- 1\n  #\n  res     <- matrix(NA, nrow = S, ncol = N.nodes)\n  for (f in 1:N.nodes)\n  {\n    probs.array.ext <- aperm(array(rep(probs.array[f, , ], S), dim=c(I, C.max + 1, S)), c(1, 3, 2))\n    res[, f]        <- apply(probs.array.ext * ind.arr + (1 - ind.arr), 2, prod)\n  }\n  return(res)\n}\n\n# P(Xs) ----\nP.tilde.s.vec <- function(Ls.mat, weights)\n{\n  return(as.vector(Ls.mat %*% weights))\n}\n\n# P(Zi = z|theta) ----\nP.izf   <- function(alpha, delta, taus, nodes, C)\n{\n  I           <- length(alpha)\n  C.max       <- max(C)\n  N.nodes     <- length(nodes)\n  probs.array <- array(NA, dim = c(N.nodes, I, C.max + 1))\n  for (z in 0:C.max)\n  {\n    probs.array[, , z + 1] <- P.Model.3478(z, alpha, delta, taus, nodes, C)\n  }\n  return(probs.array)\n}\n\n# Auxiliary functions ----\n# a.arr\na.arr <- function(alpha, delta, taus, nodes, C)\n{\n  I        <- length(alpha)\n  N.nodes  <- length(nodes)\n  C.max    <- max(C)\n  taus.ext <- cbind(0, taus)[, 1:(C.max + 1), drop = FALSE]\n  res      <- array(NA, dim = c(I, C.max + 1, N.nodes))\n  for (z in 0:C.max)\n  {\n    sum.taus <- sapply(1:I, function(i)\n    {\n      if (((C.max - C[i]) + z+1) <= (C.max + 1)) {\n        sum(taus.ext[i, ((C.max - C[i]) + 1):((C.max - C[i]) + z +1), drop = FALSE])\n      } else {0}\n    })\n    vec.ind <- (z <= C)\n    for (f in 1:N.nodes)\n    {\n      res[, z+1, f] <- vec.ind * exp( alpha * ( z * (nodes[f] - delta) - sum.taus ) )\n    }\n  }\n  return(res)\n}\n# b.arr\nb.arr <- function(alpha, delta, taus, nodes, C)\n{\n  I        <- length(alpha)\n  N.nodes  <- length(nodes)\n  C.max    <- max(C)\n  M        <- 2 * C + 1\n  taus.ext <- cbind(0, taus)[, 1:(C.max + 1), drop = FALSE]\n  res      <- array(NA, dim = c(I, C.max + 1, N.nodes))\n  for (z in 0:C.max)\n  {\n    sum.taus <- sapply(1:I, function(i)\n    {\n      if (((C.max - C[i]) + z+1) <= (C.max + 1)) {\n        sum(taus.ext[i, ((C.max - C[i]) + 1):((C.max - C[i]) + z +1), drop = FALSE])\n      } else {0}\n    })\n    vec.ind <- (z <= C)\n    for (f in 1:N.nodes)\n    {\n      res[, z+1, f] <- vec.ind * exp( alpha * ( (M - z) * (nodes[f] - delta) - sum.taus ) )\n    }\n  }\n  return(res)\n}\n# q.mat\nq.mat <- function(taus, C)\n{\n  I        <- length(C)\n  C.max    <- max(C)\n  taus.ext <- cbind(0, taus)[, 1:(C.max + 1), drop = FALSE]\n  res       <- matrix(NA, nrow = I, ncol = C.max + 1)\n  for (z in 0:C.max)\n  {\n    sum.taus <- sapply(1:I, function(i)\n    {\n      if (((C.max - C[i]) + z +1) <= (C.max + 1)) {\n        sum(taus.ext[i, ((C.max - C[i]) + 1):((C.max - C[i]) + z+1), drop = FALSE])\n      } else {0}\n    })\n    res[, z+1] <- sum.taus\n  }\n  return(res)\n}\n# g.mat\ng.mat <- function(alpha, delta, taus, nodes, C)\n{\n  res <- apply(a.arr(alpha, delta, taus, nodes, C) + b.arr(alpha, delta, taus, nodes, C), c(1, 3), sum, na.rm = TRUE)\n  return(res)\n}\n# t.mat\nt.mat <- function(delta, nodes)\n{\n  I   <- length(delta)\n  res <- t(sapply(1:I, function(i) {nodes - delta[i]}))\n  return(res)\n}\n\n# dP.alpha.arr ----\ndP.alpha.arr <- function(alpha, delta, taus, nodes, C)\n{\n  I       <- length(alpha)\n  N.nodes <- length(nodes)\n  if (length(C) == 1) {C <- rep(C, I)}\n  C.max   <- max(C)\n  M       <- 2 * C + 1\n  #\n  arr.ind <- matrix(0, nrow = I, ncol = C.max + 1)\n  for (i in 1:I)\n  {\n    arr.ind[i, 1:(C[i] + 1)] <- 1\n  }\n  arr.ind <- array(rep(arr.ind, N.nodes), dim = c(I, C.max + 1, N.nodes))\n  #\n  z.arr   <- arr.ind * aperm(array(rep(0:C.max, I * N.nodes), dim = c(C.max + 1, I, N.nodes)), c(2, 1, 3))\n  t.arr   <- aperm(array(rep(t.mat(delta, nodes), C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2))\n  g.arr   <- aperm(array(rep(g.mat(alpha, delta, taus, nodes, C), C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2))\n  q.arr   <- array(rep(q.mat(taus, C), N.nodes), dim = c(I, C.max + 1, N.nodes))\n  #\n  a.res   <- a.arr(alpha, delta, taus, nodes, C)\n  b.res   <- b.arr(alpha, delta, taus, nodes, C)\n  #\n  num1    <- a.res * (z.arr * t.arr - q.arr) + b.res * ((M - z.arr) * t.arr - q.arr)\n  den1    <- g.arr\n  sum.w   <- apply(num1, c(1, 3), sum, na.rm = TRUE)\n  sum.w   <- aperm(array(rep(sum.w, C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2))\n  num2    <- (a.res + b.res) * sum.w\n  den2    <- g.arr^2\n  return(aperm(num1 / den1 - num2 / den2, c(3, 1, 2))) # N.nodes x I x (C + 1)\n}\n\n# dP.delta.arr ----\ndP.delta.arr <- function(alpha, delta, taus, nodes, C)\n{\n  I         <- length(alpha)\n  N.nodes   <- length(nodes)\n  if (length(C) == 1) {C <- rep(C, I)}\n  C.max     <- max(C)\n  M         <- 2 * C + 1\n  #\n  arr.ind <- matrix(0, nrow = I, ncol = C.max + 1)\n  for (i in 1:I)\n  {\n    arr.ind[i, 1:(C[i] + 1)] <- 1\n  }\n  arr.ind <- array(rep(arr.ind, N.nodes), dim = c(I, C.max + 1, N.nodes))\n  #\n  alpha.arr <- array(rep(alpha, (C.max + 1) * N.nodes), dim = c(I, C.max + 1, N.nodes))\n  z.arr     <- arr.ind * aperm(array(rep(0:C.max, I * N.nodes), dim = c(C.max + 1, I, N.nodes)), c(2, 1, 3))\n  g.arr     <- aperm(array(rep(g.mat(alpha, delta, taus, nodes, C), C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2))\n  #\n  a.res     <- a.arr(alpha, delta, taus, nodes, C)\n  b.res     <- b.arr(alpha, delta, taus, nodes, C)\n  #\n  num1      <- a.res * (-alpha.arr * z.arr) + b.res * (-alpha.arr * (M - z.arr))\n  den1      <- g.arr\n  sum.w     <- apply(num1, c(1, 3), sum, na.rm = TRUE)\n  sum.w     <- aperm(array(rep(sum.w, C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2))\n  num2      <- (a.res + b.res) * sum.w\n  den2      <- g.arr^2\n  return(aperm(num1 / den1 - num2 / den2, c(3, 1, 2))) # N.nodes x I x (C + 1)\n}\n\n# dP.tau.arr ----\ndP.tau.arr <- function(alpha, delta, taus, nodes, C)\n{\n  I         <- length(alpha)\n  N.nodes   <- length(nodes)\n  if (length(C) == 1) {C <- rep(C, I)}\n  C.max     <- max(C)\n  #\n  arr.ind <- matrix(0, nrow = I, ncol = C.max + 1)\n  for (i in 1:I)\n  {\n    arr.ind[i, 1:(C[i] + 1)] <- 1\n  }\n  arr.ind <- array(rep(arr.ind, N.nodes), dim = c(I, C.max + 1, N.nodes))\n  #\n  a.res     <- a.arr(alpha, delta, taus, nodes, C)\n  b.res     <- b.arr(alpha, delta, taus, nodes, C)\n  #\n  alpha.arr <- array(rep(alpha, (C.max + 1) * N.nodes), dim = c(I, C.max + 1, N.nodes))\n  z.arr     <- arr.ind * aperm(array(rep(0:C.max, I * N.nodes), dim = c(C.max + 1, I, N.nodes)), c(2, 1, 3))\n  g.arr     <- aperm(array(rep(g.mat(alpha, delta, taus, nodes, C), C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2))\n  #\n  res <- array(NA, dim = c(I, C.max + 1, N.nodes, C.max))\n  for (k in 1:C.max)\n  {\n    Uzk.arr <- array(0, dim = c(I, C.max + 1, N.nodes))\n    Uzk.arr[ , (k + 1):(C.max + 1), ] <- 1\n    sum.w   <- apply(a.res * (-alpha.arr * Uzk.arr) + b.res * (-alpha.arr * Uzk.arr), c(1, 3), sum, na.rm = TRUE)\n    sum.w   <- aperm(array(rep(sum.w, C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2))\n    num     <- (a.res + b.res) * (g.arr * (-alpha.arr * Uzk.arr) - sum.w)\n    den     <- g.arr^2\n    res[ , , , k] <- num / den\n  }\n  return(aperm(res, c(3, 1, 2, 4)))\n}\n\n# dP.phi ----\ndP.phi <- function(alpha, delta, taus, nodes, C, param = \"alphadelta\")\n{\n  if (param == \"alphadelta\")\n  {\n    res <- list(alpha = dP.alpha.arr(alpha, delta, taus, nodes, C),\n                delta = dP.delta.arr(alpha, delta, taus, nodes, C),\n                taus  = NULL)\n  }\n  if (param == \"delta\")\n  {\n    res <- list(alpha = NULL,\n                delta = dP.delta.arr(alpha, delta, taus, nodes, C),\n                taus  = NULL)\n  }\n  if (param == \"taus\")\n  {\n    res <- list(alpha = NULL,\n                delta = NULL,\n                taus  = dP.tau.arr(alpha, delta, taus, nodes, C))\n  }\n  return(res)\n}\n\n# DlogL.dphi ----\nDlogL.dphi <- function(param = \"alphadelta\", dP, r.bar.izf, P.izf.arr)\n{\n  if (param == \"alphadelta\")\n  {\n    res.alpha <- apply(r.bar.izf * dP$alpha /  P.izf.arr, 2, sum, simplify = FALSE, na.rm = TRUE)\n    res.delta <- apply(r.bar.izf * dP$delta /  P.izf.arr, 2, sum, simplify = FALSE, na.rm = TRUE)\n    res.taus  <- NULL\n  }\n  if (param == \"delta\")\n  {\n    res.alpha <- NULL\n    res.delta <- apply(r.bar.izf * dP$delta /  P.izf.arr, 2, sum, simplify = FALSE, na.rm = TRUE)\n    res.taus  <- NULL\n  }\n  if (param == \"taus\")\n  {\n    res.alpha <- NULL\n    res.delta <- NULL\n    res.taus  <- apply(r.bar.izf * dP$taus / P.izf.arr, c(2, 4), sum, simplify = FALSE, na.rm = TRUE)\n  }\n  res <- list(alpha = res.alpha, delta = res.delta, taus = res.taus)\n  return(res)\n}\n\n# Fil GGUM ---\n# Use function Model8().\n\n# Estimate thetas and associated SE's ----\nTheta.EAP <- function(data, C, IP.res, N.nodes = 30, precision = 4)\n{\n  tmp            <- GGUM.data.condense(data)\n  data.condensed <- tmp$data.condensed\n  ind            <- tmp$ind\n  rm(tmp)\n  # Nodes and weights:\n  nodes   <- seq(-4, 4, length.out = N.nodes)\n  weights <- dnorm(nodes) / sum(dnorm(nodes))\n  #\n  S           <- nrow(data.condensed)\n  Ls.mat      <- Ls(data.condensed, IP.res$alpha, IP.res$delta, IP.res$taus, nodes, C) # S x N.nodes\n  nodes.mat   <- matrix(rep(nodes, S),   ncol = N.nodes, byrow = TRUE)           # S x N.nodes\n  weights.mat <- matrix(rep(weights, S), ncol = N.nodes, byrow = TRUE)           # S x N.nodes\n  num         <- rowSums(nodes.mat * Ls.mat * weights.mat)                       # S\n  den         <- rowSums(            Ls.mat * weights.mat)                       # S\n  res         <- num / den\n  #\n  return(list(Th.condensed = round(res, precision), Th.full = round(res[ind], precision)))\n}\n\nTheta.SE <- function(data, C, IP.res, thetas.est, N.nodes = 30, precision = 4)\n{\n  tmp            <- GGUM.data.condense(data)\n  data.condensed <- tmp$data.condensed\n  ind            <- tmp$ind\n  rm(tmp)\n  # Nodes and weights:\n  nodes   <- seq(-4, 4, length.out = N.nodes)\n  weights <- dnorm(nodes) / sum(dnorm(nodes))\n  #\n  S           <- nrow(data.condensed)\n  Ls.mat      <- Ls(data.condensed, IP.res$alpha, IP.res$delta, IP.res$taus, nodes, C)\n  nodes.mat   <- matrix(rep(nodes, S),            ncol = N.nodes, byrow = TRUE)\n  weights.mat <- matrix(rep(weights, S),          ncol = N.nodes, byrow = TRUE)\n  thetas.mat  <- matrix(rep(thetas.est$Th.condensed, N.nodes), ncol = N.nodes, byrow = FALSE)\n  num         <- rowSums(((nodes.mat - thetas.mat)^2) * Ls.mat * weights.mat)\n  den         <- rowSums(Ls.mat * weights.mat)\n  return(list(Th.SE.condensed = round(sqrt(num / den), precision), Th.SE.full = round(sqrt(num / den)[ind], precision)))\n}\n\n# SE of item parameters, Model 8 ----\nItemParamModel8.SE <- function(data, C, IP.res, N.nodes = 30, precision = 4)\n{\n  tmp            <- GGUM.data.condense(data)\n  data.condensed <- tmp$data.condensed\n  ind            <- tmp$ind\n  rm(tmp)\n  #\n  N              <- nrow(data)\n  I              <- ncol(data)\n  if (length(C) == 1) {C <- rep(C, I)}\n  C.max          <- max(C)\n  # Nodes and weights:\n  nodes   <- seq(-4, 4, length.out = N.nodes)\n  weights <- dnorm(nodes) / sum(dnorm(nodes))\n  #\n  S           <- nrow(data.condensed)\n  Ls.mat      <- Ls(data.condensed, IP.res$alpha, IP.res$delta, IP.res$taus, nodes, C)\n  Ls.arr      <- array(rep(Ls.mat, I * (C.max + 1)), dim = c(S, N.nodes, I, C.max + 1))\n  P.tilde.s   <- P.tilde.s.vec(Ls.mat, weights)\n  P.OBS.s     <- data.condensed[, I + 1] / N\n  P.izf.arr   <- array(rep(P.izf(IP.res$alpha, IP.res$delta, IP.res$taus, nodes, C), S), dim = c(N.nodes, I, C.max + 1, S))\n  P.izf.arr   <- aperm(P.izf.arr, c(4, 1, 2, 3))\n  #\n  weights.arr <- array(rep(weights, S * I * (C.max + 1)), dim = c(N.nodes, S, I, C.max + 1))\n  weights.arr <- aperm(weights.arr, c(2, 1, 3, 4))\n  H.siz       <- array(0, dim = c(S, I, C.max + 1))\n  for (s in 1:S) {\n    for (i in 1:I) {\n      H.siz[s, i, data.condensed[s, i] + 1] <- 1\n    }\n  }\n  rm(s, i)\n  H.siz  <- array(rep(H.siz, N.nodes), dim = c(S, I, C.max + 1, N.nodes))\n  H.siz  <- aperm(H.siz, c(1, 4, 2, 3))\n  #\n  tmp      <- dP.phi(IP.res$alpha, IP.res$delta, IP.res$taus, nodes, C, param = \"alphadelta\")\n  dP.alpha <- aperm(array(rep(tmp$alpha, S), dim = c(N.nodes, I, C.max + 1, S)), c(4, 1, 2, 3))\n  dP.delta <- aperm(array(rep(tmp$delta, S), dim = c(N.nodes, I, C.max + 1, S)), c(4, 1, 2, 3))\n  tmp      <- dP.phi(IP.res$alpha, IP.res$delta, IP.res$taus, nodes, C, param = \"taus\")\n  # dP.taus  <- aperm(array(rep(tmp$taus, S), dim = c(N.nodes, I, C.max + 1, C.max, S)), c(5, 1, 2, 3, 4))\n  dP.taus  <- tmp$taus\n  rm(tmp)\n  #\n  dP.tilde.s.vec.alpha <- apply(Ls.arr * weights.arr * dP.alpha * H.siz / P.izf.arr, c(1, 3), sum, na.rm = TRUE)\n  dP.tilde.s.vec.delta <- apply(Ls.arr * weights.arr * dP.delta * H.siz / P.izf.arr, c(1, 3), sum, na.rm = TRUE)\n  rm(dP.alpha, dP.delta)\n  # Ls.arr.taus          <- array(rep(Ls.arr, C.max), dim = c(S, N.nodes, I, C.max + 1, C.max))\n  # rm(Ls.arr)\n  # weights.arr.taus     <- array(rep(weights.arr, C.max), dim = c(S, N.nodes, I, C.max + 1, C.max))\n  # rm(weights.arr)\n  # H.siz.taus           <- array(rep(H.siz, C.max), dim = c(S, N.nodes, I, C.max + 1, C.max))\n  # rm(H.siz)\n  # P.izf.arr.taus       <- array(rep(P.izf.arr, C.max), dim = c(S, N.nodes, I, C.max + 1, C.max))\n  # rm(P.izf.arr)\n  # dP.tilde.s.vec.taus  <- apply(Ls.arr.taus * weights.arr.taus * dP.taus * H.siz.taus / P.izf.arr.taus, c(1, 3, 5), sum, na.rm = TRUE)\n  dP.tilde.s.vec.taus <- array(NA, dim = c(S, I, C.max))\n  for (i in 1:C.max)\n  {\n    dP.taus.use <- aperm(array(rep(dP.taus[ , , , i], S), dim = c(N.nodes, I, C.max + 1, S)), c(4, 1, 2, 3))\n    dP.tilde.s.vec.taus[, , i] <- apply(Ls.arr * weights.arr * dP.taus.use * H.siz / P.izf.arr, c(1, 3), sum, na.rm = TRUE)\n  }\n  rm(dP.taus, Ls.arr, weights.arr, H.siz, P.izf.arr, i, dP.taus.use)\n  #\n  SE.mat <- matrix(0, nrow = I, ncol = C.max + 2)\n  for (i in 1:I) {\n    dP.tilde      <- cbind(dP.tilde.s.vec.alpha[, i], dP.tilde.s.vec.delta[, i], dP.tilde.s.vec.taus[, i, ])\n    P.OBS.s.mat   <- matrix(rep(P.OBS.s  , C.max + 2), nrow = S, byrow = FALSE)\n    P.tilde.s.mat <- matrix(rep(P.tilde.s, C.max + 2), nrow = S, byrow = FALSE)\n    sum.arg       <- sqrt(P.OBS.s.mat) * dP.tilde / P.tilde.s.mat\n    Inf.i         <- N * (t(sum.arg) %*% sum.arg)\n    # SE.mat[i, ]   <- sqrt(diag(solve(Inf.i)))\n    SE.mat[i, 1:(C[i] + 2)]   <- sqrt(diag(solve(Inf.i[1:(C[i] + 2), 1:(C[i] + 2)])))\n  }\n\n  colnames(SE.mat) <- c(\"SE.alpha\", \"SE.delta\", paste0(\"SE.tau\", 1:C.max))\n  return(round(SE.mat, precision))\n}\n\n# SE of item parameters, Model 3 ----\nItemParamModel3.SE <- function(data, C, IP.res, N.nodes = 30, precision = 4)\n{\n  tmp            <- GGUM.data.condense(data)\n  data.condensed <- tmp$data.condensed\n  ind            <- tmp$ind\n  rm(tmp)\n  #\n  N              <- nrow(data)\n  I              <- ncol(data)\n  if (length(C) == 1) {C <- rep(C, I)}\n  C.max          <- max(C)\n  # Nodes and weights:\n  nodes   <- seq(-4, 4, length.out = N.nodes)\n  weights <- dnorm(nodes) / sum(dnorm(nodes))\n  #\n  S           <- nrow(data.condensed)\n  Ls.mat      <- Ls(data.condensed, IP.res$alpha, IP.res$delta, IP.res$taus, nodes, C)\n  Ls.arr      <- array(rep(Ls.mat, I * (C.max + 1)), dim = c(S, N.nodes, I, C.max + 1))\n  P.tilde.s   <- P.tilde.s.vec(Ls.mat, weights)\n  P.OBS.s     <- data.condensed[, I + 1] / N\n  P.izf.arr   <- array(rep(P.izf(IP.res$alpha, IP.res$delta, IP.res$taus, nodes, C), S), dim = c(N.nodes, I, C.max + 1, S))\n  P.izf.arr   <- aperm(P.izf.arr, c(4, 1, 2, 3))\n  #\n  weights.arr <- array(rep(weights, S * I * (C.max + 1)), dim = c(N.nodes, S, I, C.max + 1))\n  weights.arr <- aperm(weights.arr, c(2, 1, 3, 4))\n  H.siz       <- array(0, dim = c(S, I, C.max + 1))\n  for (s in 1:S) {\n    for (i in 1:I) {\n      H.siz[s, i, data.condensed[s, i] + 1] <- 1\n    }\n  }\n  rm(s, i)\n  H.siz  <- array(rep(H.siz, N.nodes), dim = c(S, I, C.max + 1, N.nodes))\n  H.siz  <- aperm(H.siz, c(1, 4, 2, 3))\n  #\n  tmp      <- dP.phi(IP.res$alpha, IP.res$delta, IP.res$taus, nodes, C, param = \"delta\")\n  dP.delta <- aperm(array(rep(tmp$delta, S), dim = c(N.nodes, I, C.max + 1, S)), c(4, 1, 2, 3))\n  tmp      <- dP.phi(IP.res$alpha, IP.res$delta, IP.res$taus, nodes, C, param = \"taus\")\n  dP.taus  <- aperm(array(rep(tmp$taus, S), dim = c(N.nodes, I, C.max + 1, C.max, S)), c(5, 1, 2, 3, 4))\n  # dP.taus  <- apply(dP.taus, c(1:2, 4:5), sum, na.rm = TRUE)\n  rm(tmp)\n  #\n  dP.tilde.s.vec.delta <- apply(Ls.arr * weights.arr * dP.delta * H.siz / P.izf.arr, c(1, 3), sum, na.rm = TRUE)\n  rm(dP.delta)\n  Ls.arr.taus          <- array(rep(Ls.arr, C.max), dim = c(S, N.nodes, I, C.max + 1, C.max))\n  rm(Ls.arr)\n  weights.arr.taus     <- array(rep(weights.arr, C.max), dim = c(S, N.nodes, I, C.max + 1, C.max))\n  rm(weights.arr)\n  H.siz.taus           <- array(rep(H.siz, C.max), dim = c(S, N.nodes, I, C.max + 1, C.max))\n  # rm(H.siz)\n  P.izf.arr.taus       <- array(rep(P.izf.arr, C.max), dim = c(S, N.nodes, I, C.max + 1, C.max))\n  rm(P.izf.arr)\n  dP.tilde.s.vec.taus  <- apply(Ls.arr.taus * weights.arr.taus * dP.taus * H.siz.taus / P.izf.arr.taus, c(1, 5), sum, na.rm = TRUE)\n  rm(dP.taus, Ls.arr.taus, weights.arr.taus, H.siz.taus, P.izf.arr.taus)\n  #\n  Inf.mat <- matrix(0, nrow = I + C.max, ncol = I + C.max)\n#   for (i1 in 1:I) {\n#     for (i2 in i1:I) {\n#       dP.tilde        <- dP.tilde.s.vec.delta[, i1] * dP.tilde.s.vec.delta[, i2]\n#       Inf.mat[i1, i2] <- N * sum(P.OBS.s * dP.tilde / (P.tilde.s^2))\n#     }\n#   }\n  for (i1 in 1:I) {\n    dP.tilde        <- dP.tilde.s.vec.delta[, i1] * dP.tilde.s.vec.delta[, i1]\n    Inf.mat[i1, i1] <- N * sum(P.OBS.s * dP.tilde / (P.tilde.s^2))\n  }\n  for (i1 in 1:C.max) {\n    for (i2 in i1:C.max) {\n      dP.tilde        <- dP.tilde.s.vec.taus[, i1, drop = FALSE] * dP.tilde.s.vec.taus[, i2, drop = FALSE]\n      Inf.mat[I + i1, I + i2] <- N * sum(P.OBS.s * dP.tilde / (P.tilde.s^2))\n    }\n  }\n  for (i1 in 1:I) {\n    for (i2 in 1:C.max) {\n      dP.tilde        <- dP.tilde.s.vec.delta[, i1] * dP.tilde.s.vec.taus[, i2, drop = FALSE]\n      Inf.mat[i1, I + i2] <- N * sum(P.OBS.s * dP.tilde / (P.tilde.s^2))\n    }\n  }\n  Inf.mat <- Inf.mat + t(Inf.mat) - diag(diag(Inf.mat))\n  SE.mat  <- matrix(sqrt(diag(solve(Inf.mat))), ncol = 1)\n  rownames(SE.mat) <- c(paste0(\"SE.delta\", 1:I), paste0(\"SE.tau\", 1:C.max))\n  #\n  return(list(Delta = round(SE.mat[1:I, ], precision), Taus = round(SE.mat[(I+1):(I + C.max), ], precision)))\n}\n\n# Plot IRF ----\nplot.GGUM <- function(C, IP.res, items = NULL, x.lim = 4, ThetaminDelta = TRUE) {\n  if (length(C) == 1) {C <- rep(C, length(IP.res$alpha))}\n  M     <- 2 * C + 1\n  C.max <- max(C)\n\n  I         <- length(IP.res$alpha)\n  alpha     <- IP.res$alpha\n  delta     <- IP.res$delta\n  taus      <- IP.res$taus\n  if (ThetaminDelta == TRUE) {\n    th.lims   <- cbind(delta - x.lim, delta + x.lim)\n    th.vals   <- t(apply(th.lims, 1, function(vec) {seq(vec[1], vec[2], length.out = 100)}))\n    x         <- seq(-x.lim, x.lim, length.out = 100)\n  } else {\n    th.lims   <- t(sapply(delta, function(d) {c(-max(ceiling(d), 4), max(4, ceiling(d)))}))\n    th.vals   <- t(apply(th.lims, 1, function(vec) {seq(vec[1], vec[2], length.out = 100)}))\n    x         <- seq(-x.lim, x.lim, length.out = 100)\n  }\n  #\n  if (is.null(items)) {I.plot <- 1:I} else {I.plot <- items}\n  for (i in 1:length(I.plot)) {\n    it <- I.plot[i]\n    invisible(readline(prompt=\"Press [enter] to continue\"))\n    #\n    plot(x, P.Model.3478(0, alpha[it], delta[it], taus[it, (C.max - C[it] + 1):(C.max - C[it] + M[it])], th.vals[it, ], C[it]),\n         type = \"l\", lty = 1, col = plasma(C[it] + 1)[1], lwd = 2,\n         xlim = c(-x.lim, x.lim), ylim = 0:1,\n         xaxt = \"n\", xlab = \"\", yaxt = \"n\", ylab = \"\", main = paste(\"Item\", it))\n    for (c in 1:C[it]) {\n      points(x, P.Model.3478(c, alpha[it], delta[it], taus[it, (C.max - C[it] + 1):(C.max - C[it] + M[it])], th.vals[it, ], C[it]),\n             type = \"l\", lty = 1, col = plasma(C[it] + 1)[c + 1], lwd = 2,\n             xlim = c(-x.lim, x.lim), ylim = 0:1)\n    }\n    axis(1, at = seq(-x.lim, x.lim, 1))\n    axis(2, at = seq(0, 1, .20), las = 1)\n    if (ThetaminDelta == TRUE) {mtext(expression(paste(theta, \" - \", delta)), side = 1, line = 2.5, cex = 1.2)} else {\n      mtext(expression(paste(\"Item location \", delta)), side = 1, line = 2.5, cex = 1.2)\n    }\n    mtext(expression(paste(\"P(X=1|\", theta, \")\")), side = 2, line = 2.5, cex = 1.2)\n    #\n    legend(\"top\", paste0(\"C = \", 0:C[it]), col = plasma(C[it] + 1),\n           lty = 1, lwd = 2, inset = .01, cex = .8, ncol = 2)\n  }\n}\n\n# Plot test characteristic curve ----\nplot.TestCharacteristicCurve.GGUM <- function(data, C, IP.res, Th.res) {\n  if (length(C) == 1) {C <- rep(C, length(IP.res$alpha))}\n  M     <- 2 * C + 1\n  C.max <- max(C)\n  #\n  alpha     <- IP.res$alpha\n  delta     <- IP.res$delta\n  taus      <- IP.res$taus\n  theta     <- Th.res[[2]]\n  I         <- length(IP.res$alpha)\n  N         <- length(theta)\n  # Test characteristic curve:\n  OBS.scores      <- data\n  theta.exp       <- seq(min(-4, min(theta)), max(4, max(theta)), length.out = 1000)\n  N.groups        <- 100\n  int.lims        <- quantile(theta.exp, probs = seq(0, 1, 1 / (N.groups - 1)))\n  names(int.lims) <- NULL\n  #\n  scores.mat <- matrix(0, nrow = I, ncol = C.max + 1)\n  for (i in 1:I) {\n    scores.mat[i, 1:(C[i] + 1)] <- 0:C[i]\n  }\n  scores.arr <- aperm(array(rep(scores.mat, N), dim = c(I, C.max + 1, N.groups)), c(3, 1, 2))\n  EXP.scores <- apply(P.izf(alpha, delta, taus, int.lims, C) * scores.arr, 1, sum)\n  res        <- cbind(th =  int.lims, observed = rep(NA, N.groups), expected = EXP.scores)\n  for (int in 1:N.groups) {\n    pos.obs     <- which( (theta >= int.lims[int]) & (theta < int.lims[int + 1]))\n    if (length(pos.obs) > 0) {\n      res[int, 2] <- mean(rowSums(OBS.scores[pos.obs, , drop = FALSE], na.rm = TRUE))\n    }\n  }\n  #\n  plot(res[, 1], res[, 3], type = \"l\", lty = 1, lwd = 2,\n       xlim = c(theta.exp[1], theta.exp[1000]),\n       ylim = c(0, ceiling(max(res[, 3], na.rm = TRUE))),\n       xaxt = \"n\", xlab = \"\", yaxt = \"n\", ylab = \"\", main = \"Test Characteristic Curve\")\n  points(res[, 1], res[, 2], type = \"p\", pch = 21, bg = \"grey\")\n  axis(1, at = seq(floor(theta.exp[1]), ceiling(theta.exp[1000]), 1))\n  axis(2, at = seq(0, ceiling(max(res[, 3], na.rm = TRUE)), 10), las = 1)\n  mtext(expression(theta), side = 1, line = 2.5, cex = 1.2)\n  mtext(\"Total Score\", side = 2, line = 2.5, cex = 1.2)\n  #\n  cor.OBS.EXP.means <- cor(res[, 2], res[, 3], use = \"pairwise.complete.obs\")\n  scores.arr.N      <- aperm(array(rep(scores.mat, N), dim = c(I, C.max + 1, N)), c(3, 1, 2))\n  EXP.scores.N      <- apply(P.izf(alpha, delta, taus, theta, C) * scores.arr.N, 1:2, sum)\n  cor.OBS.EXP.raw   <- cor(c(OBS.scores), c(EXP.scores.N), use = \"pairwise.complete.obs\")\n  #\n  res.out           <- res[, c(1, 3)]\n  colnames(res.out) <- c(\"Theta\", \"TotalScore\")\n  return(list(res.out, cor.OBS.EXP.raw = round(cor.OBS.EXP.raw, 4), cor.OBS.EXP.means = round(cor.OBS.EXP.means, 4)))\n}\n\n# Plot item characteristic curves ----\nplot.ItemCharacteristicCurve.GGUM <- function(data, C, IP.res, Th.res, items = NULL) {\n  if (length(C) == 1) {C <- rep(C, length(IP.res$alpha))}\n  M     <- 2 * C + 1\n  C.max <- max(C)\n  #\n  alpha     <- IP.res$alpha\n  delta     <- IP.res$delta\n  taus      <- IP.res$taus\n  theta     <- Th.res[[2]]\n  I         <- length(IP.res$alpha)\n  N         <- length(theta)\n  # Item characteristic curves:\n  OBS.scores      <- data\n  theta.exp       <- seq(min(-4, min(theta)), max(4, max(theta)), length.out = 1000)\n  N.groups        <- 50\n  int.lims        <- quantile(theta.exp, probs = seq(0, 1, 1 / (N.groups - 1)))\n  names(int.lims) <- NULL\n  #\n  scores.mat <- matrix(0, nrow = I, ncol = C.max + 1)\n  for (i in 1:I) {\n    scores.mat[i, 1:(C[i] + 1)] <- 0:C[i]\n  }\n  scores.arr <- aperm(array(rep(scores.mat, N.groups), dim = c(I, C.max + 1, N.groups)), c(3, 1, 2))\n  EXP.scores <- apply(P.izf(alpha, delta, taus, int.lims, C) * scores.arr, 1:2, sum)\n  res        <- list(th =  int.lims, observed = matrix(NA, N.groups, I), expected = EXP.scores)\n  for (int in 1:N.groups) {\n    pos.obs     <- which( (theta >= int.lims[int]) & (theta < int.lims[int + 1]))\n    if (length(pos.obs) > 0) {\n      res[[2]][int, ] <- colMeans(OBS.scores[pos.obs, , drop = FALSE], na.rm = TRUE)\n    }\n  }\n  #\n  if (is.null(items)) {I.plot <- 1:I} else {I.plot <- items}\n  for (i in 1:length(I.plot)) {\n    it <- I.plot[i]\n    invisible(readline(prompt=\"Press [enter] to continue\"))\n    #\n    plot(res[[1]], res[[3]][, it], type = \"l\", lty = 1, lwd = 2,\n         xlim = c(theta.exp[1], theta.exp[1000]),\n         ylim = c(0, ceiling(max(res[[3]][, it], na.rm = TRUE))),\n         xaxt = \"n\", xlab = \"\", yaxt = \"n\", ylab = \"\", main = paste0(\"Item Characteristic Curve (Item\", it, \")\"))\n    points(res[[1]], res[[2]][, it], type = \"p\", pch = 21, bg = \"grey\")\n    axis(1, at = seq(floor(theta.exp[1]), ceiling(theta.exp[1000]), 1))\n    axis(2, at = seq(0, ceiling(max(res[[3]][, it], na.rm = TRUE)), 1), las = 1)\n    mtext(expression(theta), side = 1, line = 2.5, cex = 1.2)\n    mtext(\"Item Score\", side = 2, line = 2.5, cex = 1.2)\n    legend(\"topleft\", c(\"Expected\", \"Observed\"), col = \"black\",\n           lty = c(1, NA), pch = c(NA, 21), pt.bg = \"grey\", lwd = c(2, 1), inset = .01, cex = .8, pt.cex = 1)\n  }\n  #\n  scores.arr.N <- aperm(array(rep(scores.mat, N), dim = c(I, C.max + 1, N)), c(3, 1, 2))\n  EXP.scores.N <- apply(P.izf(alpha, delta, taus, theta, C) * scores.arr.N, 1:2, sum)\n  return(cor.OBS.EXP.items = round(diag(cor(OBS.scores, EXP.scores.N, use = \"pairwise.complete.obs\")), 4))\n}\n\n# dP.theta.arr (seems not needed; not fully debbuged) ----\n# dP.theta.arr <- function(alpha, delta, taus, nodes, C)\n# {\n#   I       <- length(alpha)\n#   N.nodes <- length(nodes)\n#   if (length(C) == 1) {C <- rep(C, I)}\n#   C.max   <- max(C)\n#   M       <- 2 * C + 1\n#   #\n#   arr.ind <- matrix(0, nrow = I, ncol = C.max + 1)\n#   for (i in 1:I)\n#   {\n#     arr.ind[i, 1:(C[i] + 1)] <- 1\n#   }\n#   arr.ind   <- array(rep(arr.ind, N.nodes), dim = c(I, C.max + 1, N.nodes))\n#   #\n#   alpha.arr <- array(rep(alpha, (C.max + 1) * N.nodes), dim = c(I, C.max + 1, N.nodes))\n#   z.arr     <- arr.ind * aperm(array(rep(0:C.max, I * N.nodes), dim = c(C.max + 1, I, N.nodes)), c(2, 1, 3))\n#   g.arr     <- aperm(array(rep(g.mat(alpha, delta, taus, nodes, C), C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2))\n#   # data.arr  <-\n#   #\n#   a.res     <- a.arr(alpha, delta, taus, nodes, C)\n#   b.res     <- b.arr(alpha, delta, taus, nodes, C)\n#   #\n#   num1      <- a.res * alpha.arr * z.arr + b.res * alpha.arr * (M - z.arr)\n#   sum.w     <- apply(num1, c(1, 3), sum, na.rm = TRUE)\n#   sum.w     <- aperm(array(rep(sum.w, C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2))\n#   num2      <- (a.res + b.res) * sum.w\n#   den       <- g.arr^2\n#   #\n#   res       <- ((num1 * g.arr) - num2) / den\n#   res       <- aperm(res, c(3, 1, 2))  # N x I x (C + 1)\n#   return(res)\n# }\n\n# d2logP.dtheta2.arr ----\nd2logP.dtheta2.arr <- function(data, alpha, delta, taus, theta, C)\n{\n  I <- length(alpha)\n  if (length(C) == 1) {C <- rep(C, I)}\n  C.max   <- max(C)\n  M       <- 2 * C + 1\n  # Nodes (weights seem not needed):\n  N.nodes <- 100\n  nodes   <- seq(min(-4, min(theta)), max(4, max(theta)), length.out = N.nodes)\n  #\n  arr.ind <- matrix(0, nrow = I, ncol = C.max + 1)\n  for (i in 1:I)\n  {\n    arr.ind[i, 1:(C[i] + 1)] <- 1\n  }\n  arr.ind   <- array(rep(arr.ind, N.nodes), dim = c(I, C.max + 1, N.nodes))\n  #\n  alpha.arr <- array(rep(alpha, (C.max + 1) * N.nodes), dim = c(I, C.max + 1, N.nodes))\n  z.arr     <- arr.ind * aperm(array(rep(0:C.max, I * N.nodes), dim = c(C.max + 1, I, N.nodes)), c(2, 1, 3))\n  g.arr     <- aperm(array(rep(g.mat(alpha, delta, taus, nodes, C), C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2))\n  #\n  a.res     <- a.arr(alpha, delta, taus, nodes, C)\n  b.res     <- b.arr(alpha, delta, taus, nodes, C)\n  #\n  part1     <- (alpha.arr * (z.arr^2) * a.res + alpha * ((M - z.arr)^2) * b.res) / (a.res + b.res)\n  part2     <- (z.arr * a.res + (M - z.arr) * b.res) / (a.res + b.res)\n  part3     <- (alpha.arr * z.arr * a.res + alpha * (M - z.arr) * b.res) / (a.res + b.res)\n  part4     <- apply(part1 * (a.res + b.res), c(1, 3), sum, na.rm = TRUE)\n  part4     <- aperm(array(rep(part4, C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2)) / g.arr\n  part5     <- apply(part3 * (a.res + b.res), c(1, 3), sum, na.rm = TRUE)\n  part5     <- aperm(array(rep(part5, C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2)) / g.arr\n  part6     <- apply(part2 * (a.res + b.res), c(1, 3), sum, na.rm = TRUE)\n  part6     <- aperm(array(rep(part6, C.max + 1), dim = c(I, N.nodes, C.max + 1)), c(1, 3, 2)) / g.arr\n  #\n  res  <- alpha.arr * (part1 - (part2 * part3) - part4 + (part5 * part6))\n  res  <- aperm(res, c(3, 1, 2))\n  return(list(d2logP.dtheta2 = res, N.nodes = N.nodes, nodes = nodes))\n}\n\n# Plot test information ----\nplot.TestInf <- function(data, C, IP.res, Th.res) {\n  if (length(C) == 1) {C <- rep(C, length(IP.res$alpha))}\n  alpha     <- IP.res$alpha\n  delta     <- IP.res$delta\n  taus      <- IP.res$taus\n  theta     <- Th.res[[2]]\n  #\n  d2res         <- d2logP.dtheta2.arr(data, alpha, delta, taus, theta, C)\n  # Nodes:\n  N.nodes <- d2res$N.nodes\n  nodes   <- d2res$nodes\n  #\n  probs         <- P.izf(alpha, delta, taus, nodes, C)\n  res           <- -apply(probs * (d2res$d2logP.dtheta2), 1, sum, na.rm = TRUE)\n  res           <- cbind(nodes, res)\n  colnames(res) <- c(\"Theta\", \"Inf\")\n  #\n  plot(res[, 1], res[, 2], type = \"l\", lty = 1, lwd = 2,\n       xlim = c(nodes[1], nodes[N.nodes]),\n       ylim = c(0, ceiling(max(res[, 2], na.rm = TRUE)) + 1),\n       xaxt = \"n\", xlab = \"\", yaxt = \"n\", ylab = \"\", main = \"Test Information Function\")\n  axis(1, at = seq(floor(nodes[1]), ceiling(nodes[N.nodes]), 1))\n  axis(2, at = seq(0, ceiling(max(res[, 2], na.rm = TRUE) + 1), 10), las = 1)\n  mtext(expression(theta), side = 1, line = 2.5, cex = 1.2)\n  mtext(\"Information\", side = 2, line = 2.5, cex = 1.2)\n  #\n  return(TestInformation = res)\n}\n\n# Plot item information ----\nplot.ItemInf <- function(data, C, IP.res, Th.res, items = NULL) {\n  if (length(C) == 1) {C <- rep(C, length(IP.res$alpha))}\n  alpha     <- IP.res$alpha\n  delta     <- IP.res$delta\n  taus      <- IP.res$taus\n  theta     <- Th.res[[2]]\n  I         <- length(alpha)\n  #\n  d2res         <- d2logP.dtheta2.arr(data, alpha, delta, taus, theta, C)\n  # Nodes:\n  N.nodes <- d2res$N.nodes\n  nodes   <- d2res$nodes\n  #\n  probs         <- P.izf(alpha, delta, taus, nodes, C)\n  res           <- -apply(probs * (d2res$d2logP.dtheta2), 1:2, sum, na.rm = TRUE)\n  res           <- cbind(nodes, res)\n  colnames(res) <- c(\"Theta\", paste0(\"Inf\", 1:I))\n  #\n  if (is.null(items)) {I.plot <- 1:I} else {I.plot <- items}\n  for (i in 1:length(I.plot)) {\n    it <- I.plot[i]\n    invisible(readline(prompt=\"Press [enter] to continue\"))\n    #\n    plot(res[, 1], res[, it + 1], type = \"l\", lty = 1, lwd = 2,\n         xlim = c(nodes[1], nodes[N.nodes]),\n         ylim = c(0, ceiling(max(res[, 2:(I + 1)], na.rm = TRUE)) + 1),\n         xaxt = \"n\", xlab = \"\", yaxt = \"n\", ylab = \"\", main = paste0(\"Item Information Function (Item\", it, \")\"))\n    axis(1, at = seq(floor(nodes[1]), ceiling(nodes[N.nodes]), 1))\n    axis(2, at = seq(0, ceiling(max(res[, 2:(I + 1)], na.rm = TRUE) + 1), 2), las = 1)\n    mtext(expression(theta), side = 1, line = 2.5, cex = 1.2)\n    mtext(\"Information\", side = 2, line = 2.5, cex = 1.2)\n  }\n  #\n  return(ItemInformation = res[, c(1, I.plot + 1)])\n}\n\n# Export data in MODFIT friendly format ----\nExport.MODFIT <- function(data, C, IP, file.name = \"MyData\") {\n  library(xlsx)\n  # Missing values: NA -> 9\n  data[is.na(data)] <- 9\n  write.xlsx2(data, paste0(file.name, \"SCORES.xlsx\"), col.names = FALSE, row.names = FALSE)\n  write.xlsx2(cbind(IP$alpha, IP$delta, IP$taus[, 1:C]), paste0(file.name, \"IPs.xlsx\"), col.names = FALSE, row.names = FALSE)\n}\n\n\n\n\n\n\n",
    "created" : 1504619475267.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1110934500",
    "id" : "7F2DE08D",
    "lastKnownWriteTime" : 1504626540,
    "last_content_update" : 1504626540766,
    "path" : "C:/Users/Sebastian/Dropbox/Research_Master/2016-2017/Student_Assitant_ship/Pack/GGUM/R/GGUM.R",
    "project_path" : "R/GGUM.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}